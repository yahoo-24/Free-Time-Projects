$date
  Tue Jul 23 08:18:24 2024
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module cpu_tb $end
$var reg 1 ! status $end
$var reg 1 " clk $end
$var reg 8 # checkram[7:0] $end
$var reg 8 $ checkalu[7:0] $end
$var reg 8 % out1[7:0] $end
$var reg 8 & out2[7:0] $end
$var reg 8 ' in1[7:0] $end
$scope module uut $end
$var reg 1 ( status $end
$var reg 8 ) checkram[7:0] $end
$var reg 8 * checkalu[7:0] $end
$var reg 1 + clk $end
$var reg 8 , out1[7:0] $end
$var reg 8 - out2[7:0] $end
$var reg 8 . in1[7:0] $end
$comment ins is not handled $end
$var integer 32 / i $end
$var reg 1 0 ld $end
$var reg 1 1 st $end
$var reg 16 2 op[15:0] $end
$var reg 8 3 reg[7:0] $end
$var reg 8 4 resultalu[7:0] $end
$var reg 8 5 muxed[7:0] $end
$var reg 8 6 resultram[7:0] $end
$var reg 8 7 o1[7:0] $end
$var reg 8 8 o2[7:0] $end
$var reg 3 9 addr[2:0] $end
$var reg 3 : addr1[2:0] $end
$var reg 3 ; addr2[2:0] $end
$var reg 3 < mem[2:0] $end
$var reg 4 = code[3:0] $end
$var reg 2 > x[1:0] $end
$var reg 1 ? statusn $end
$var reg 1 @ statusv $end
$var reg 1 A statusc $end
$var reg 1 B statusz $end
$scope module registerbank $end
$var reg 8 C input[7:0] $end
$var reg 8 D output1[7:0] $end
$var reg 8 E output2[7:0] $end
$var reg 3 F address[2:0] $end
$var reg 1 G load $end
$var reg 3 H address1[2:0] $end
$var reg 3 I address2[2:0] $end
$var reg 1 J clk $end
$comment memory is not handled $end
$upscope $end
$scope module alu $end
$var reg 8 K a[7:0] $end
$var reg 8 L b[7:0] $end
$var reg 4 M opcode[3:0] $end
$var reg 1 N v $end
$var reg 1 O n $end
$var reg 1 P z $end
$var reg 1 Q c $end
$var reg 8 R result[7:0] $end
$var reg 8 S muxa[7:0] $end
$var reg 8 T muxb[7:0] $end
$var reg 8 U result_au[7:0] $end
$var reg 8 V result_lu[7:0] $end
$var reg 8 W resultx[7:0] $end
$scope module u1 $end
$var reg 8 X a[7:0] $end
$var reg 1 Y sel_1 $end
$var reg 8 Z out1[7:0] $end
$upscope $end
$scope module u2 $end
$var reg 8 [ a[7:0] $end
$var reg 1 \ sel_1 $end
$var reg 8 ] out1[7:0] $end
$upscope $end
$scope module u3 $end
$var reg 8 ^ a[7:0] $end
$var reg 8 _ b[7:0] $end
$var reg 1 ` cin $end
$var reg 1 a v $end
$var reg 1 b c $end
$var reg 8 c out_au[7:0] $end
$var reg 1 d c1 $end
$var reg 1 e c2 $end
$var reg 1 f c3 $end
$var reg 1 g c4 $end
$var reg 1 h c5 $end
$var reg 1 i c6 $end
$var reg 1 j c7 $end
$var reg 1 k c8 $end
$scope module u1 $end
$var reg 1 l a $end
$var reg 1 m b $end
$var reg 1 n cin $end
$var reg 1 o cout $end
$var reg 1 p sum $end
$upscope $end
$scope module u2 $end
$var reg 1 q a $end
$var reg 1 r b $end
$var reg 1 s cin $end
$var reg 1 t cout $end
$var reg 1 u sum $end
$upscope $end
$scope module u3 $end
$var reg 1 v a $end
$var reg 1 w b $end
$var reg 1 x cin $end
$var reg 1 y cout $end
$var reg 1 z sum $end
$upscope $end
$scope module u4 $end
$var reg 1 { a $end
$var reg 1 | b $end
$var reg 1 } cin $end
$var reg 1 !" cout $end
$var reg 1 "" sum $end
$upscope $end
$scope module u5 $end
$var reg 1 #" a $end
$var reg 1 $" b $end
$var reg 1 %" cin $end
$var reg 1 &" cout $end
$var reg 1 '" sum $end
$upscope $end
$scope module u6 $end
$var reg 1 (" a $end
$var reg 1 )" b $end
$var reg 1 *" cin $end
$var reg 1 +" cout $end
$var reg 1 ," sum $end
$upscope $end
$scope module u7 $end
$var reg 1 -" a $end
$var reg 1 ." b $end
$var reg 1 /" cin $end
$var reg 1 0" cout $end
$var reg 1 1" sum $end
$upscope $end
$scope module u8 $end
$var reg 1 2" a $end
$var reg 1 3" b $end
$var reg 1 4" cin $end
$var reg 1 5" cout $end
$var reg 1 6" sum $end
$upscope $end
$upscope $end
$scope module u4 $end
$var reg 8 7" a[7:0] $end
$var reg 8 8" b[7:0] $end
$var reg 1 9" sel_1 $end
$var reg 1 :" sel_2 $end
$var reg 8 ;" out_lu[7:0] $end
$upscope $end
$scope module u5 $end
$var reg 8 <" in1[7:0] $end
$var reg 8 =" in2[7:0] $end
$var reg 1 >" sel $end
$var reg 8 ?" out1[7:0] $end
$upscope $end
$upscope $end
$scope module ram $end
$var reg 8 @" input[7:0] $end
$var reg 8 A" output[7:0] $end
$var reg 3 B" address[2:0] $end
$var reg 1 C" load $end
$var reg 1 D" clk $end
$comment memory is not handled $end
$upscope $end
$scope module mux $end
$var reg 2 E" sel[1:0] $end
$var reg 8 F" a[7:0] $end
$var reg 8 G" b[7:0] $end
$var reg 8 H" c[7:0] $end
$var reg 8 I" y[7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
1!
0"
b00000000 #
b11111111 $
b00000000 %
b00000000 &
b00000000 '
1(
b00000000 )
b11111111 *
0+
b00000000 ,
b00000000 -
b00000000 .
b0 /
U0
U1
bUUUUUUUUUUUUUUUU 2
bUUUUUUUU 3
b11111111 4
b00000000 5
b00000000 6
b00000000 7
b00000000 8
b000 9
b000 :
b000 ;
b000 <
b1111 =
b11 >
1?
0@
1A
0B
b00000000 C
b00000000 D
b00000000 E
b000 F
UG
b000 H
b000 I
0J
b00000000 K
b00000000 L
b1111 M
0N
1O
0P
1Q
b11111111 R
b11111111 S
b11111111 T
b11111111 U
b11111111 V
b11111111 W
b00000000 X
1Y
b11111111 Z
b00000000 [
1\
b11111111 ]
b11111111 ^
b11111111 _
1`
0a
1b
b11111111 c
1d
1e
1f
1g
1h
1i
1j
1k
1l
1m
1n
1o
1p
1q
1r
1s
1t
1u
1v
1w
1x
1y
1z
1{
1|
1}
1!"
1""
1#"
1$"
1%"
1&"
1'"
1("
1)"
1*"
1+"
1,"
1-"
1."
1/"
10"
11"
12"
13"
14"
15"
16"
b00000000 7"
b11111111 8"
19"
1:"
b11111111 ;"
b11111111 <"
b11111111 ="
1>"
b11111111 ?"
b00000000 @"
b00000000 A"
b000 B"
UC"
0D"
b11 E"
bUUUUUUUU F"
b00000000 G"
b11111111 H"
b00000000 I"
#10000000
1"
1+
b1 /
00
01
b0110000110110101 2
0G
1J
0C"
1D"
#20000000
0"
0+
0J
0D"
#30000000
1"
b00110110 '
1+
b00110110 .
b10 /
10
b0110000100100110 2
b00110110 3
b00110110 5
b101 9
b00 >
b00110110 C
b101 F
1G
1J
1D"
b00 E"
b00110110 F"
b00110110 I"
#40000000
0"
0+
0J
0D"
#50000000
1"
b00100100 '
1+
b00100100 .
b11 /
b0010110111101110 2
b00100100 3
b00100100 5
b110 9
b00100100 C
b110 F
1J
1D"
b00100100 F"
b00100100 I"
#60000000
0"
0+
0J
0D"
#70000000
1"
b00010010 $
b00110110 %
b00100100 &
b00010010 '
b00010010 *
1+
b00110110 ,
b00100100 -
b00010010 .
b100 /
b1000000010100111 2
b00010010 4
b00010010 5
b00110110 7
b00100100 8
b111 9
b101 :
b110 ;
b0110 =
b10 >
0?
0B
b00010010 C
b00110110 D
b00100100 E
b111 F
b101 H
b110 I
1J
b00110110 K
b00100100 L
b0110 M
0O
0P
b00010010 R
b00110110 S
b11011011 T
b00010010 U
b11101101 V
b00010010 W
b00100100 X
b11011011 Z
b00110110 [
0\
b00110110 ]
b00110110 ^
b11011011 _
b00010010 c
0l
0p
1q
1u
1v
0w
0z
0{
0""
1#"
1'"
1("
0)"
0,"
0-"
01"
02"
06"
b00110110 7"
b11011011 8"
09"
b11101101 ;"
b00010010 <"
b11101101 ="
0>"
b00010010 ?"
b00110110 @"
1D"
b10 E"
b00010010 H"
b00010010 I"
#80000000
0"
0+
0J
0D"
#90000000
1!
1"
b11101110 $
b00010010 %
b11101110 '
1(
b11101110 *
1+
b00010010 ,
b11101110 .
b101 /
00
11
b0000000000000000 2
b11101110 4
b11101110 5
b00010010 7
b111 :
b100 <
1?
0@
0A
b11101110 C
b00010010 D
0G
b111 H
1J
b00010010 K
0N
1O
0Q
b11101110 R
b00010010 S
b11101110 U
b11001001 V
b11101110 W
b00010010 [
b00010010 ]
b00010010 ^
0a
0b
b11101110 c
0f
0g
0i
0j
0k
0v
0y
1z
0}
0!"
1""
0%"
0'"
0("
0+"
1,"
0/"
00"
11"
04"
05"
16"
b00010010 7"
b11001001 ;"
b11101110 <"
b11001001 ="
b11101110 ?"
b00010010 @"
b100 B"
1C"
1D"
b11101110 H"
b11101110 I"
#100000000
0"
0+
0J
0D"
#110000000
1"
b00010010 #
b00010010 )
1+
b110 /
01
b00010010 6
1J
b00010010 A"
0C"
1D"
b00010010 G"
#120000000
0"
0+
0J
0D"
#130000000
1"
1+
b111 /
1J
1D"
